\documentclass[a4paper]{article}

\usepackage{../project}

\usepackage{amsmath,amsthm,amsfonts} % packages for math
\usepackage{graphicx,tikz,pgfplots,setspace} % packages for graphics
\usepackage[margin=1in]{geometry}
\usepackage{subcaption}
\doublespacing
\usepackage{float}
\usepackage{multirow}
\usepackage{enumerate}
\usepackage{lipsum}%% a garbage package you don't need except to create examples.
\usepackage{fancyhdr}
\usepackage{gensymb}
\usepackage{array}

\pgfplotsset{compat=1.14}

\pagestyle{fancy}
\rhead{Page \thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\usepackage{pgfplotstable}
\usepackage{placeins}

% ========================================================================
% Put your lab title, names, and a brief abstract here.
\title{Shor's Algorithm}
\lhead{Elliott Pryor, Benjamin Bushnell, REID HELP}
\author{Elliott Pryor, Benjamin Bushnell, REID HELP}
\date{13 November, 2019}
% ========================================================================
\usepackage{multicol}
\setlength{\columnsep}{0cm}
\begin{document}


\maketitle % This line creates the title (DO NOT CHANGE)
\section{The Problem}
The problem of factoring large numbers has existed for centuries. Euclid's algorithm provides a very efficient way to determine the greatest common divisor of two numbers (GCD). Say we look for $GCD(a,b)$ then $a$ is a factor of $b$ if the $GCD(a, b) > 1$. If we have one of the factors, it is very easy to find the other factor as we can just divide the number by its factor. However, factoring very large numbers using Euclid's algorithm is very time consuming as we have to try every single number less than the value we are factoring. We can make a few improvements to our guesses; however, classically this problem cannot be solved in polynomial time.

This is very important to modern security. We use RSA encryption as a way to encrypt our data. 
%TODO talk about RSA (how it works at very high level? and why its hard to break)
%TODO Impact on society
%TODO How shor's algorithm makes things faster so we can break RSA really fast

For sections \ref{classicalSec} and \ref{quantumSec} assume we are trying to find: 
$$ab = C$$
where $a$ and $b$ are factors of $n$ and $a,b,C \in \naturals$.

\section{Classical Computation}
\label{classicalSec}
The classical part of this algorithm is really simple. We just have to guess a random number as our factor. Then we use Eucild's algorithm to verify that we didn't get extremely lucky and guess a factor. If we guess a factor, then we don't need to use the quantum part of the algorithm. Then we feed our guess (which we know does NOT share factors with the number in question) into the quantum algorithm. 


\section{The Quantum Algorithm}
\label{quantumSec}

The quantum part of this algorithm is what turns the random number that we guessed into the actual factor. In short, it does this by finding the period of some function that we can relate to the factors. Given that that is a gross oversimplification of what happens, we will cover some of the math supporting Shor's Algorithm. 

First, we must define a few relations. 

\begin{theorem} %I'm not proving the theorem, but i'm refrencing it. How should this be done mathematically?
%TODO find name of this theorem

Given $a,b \in \integers$ and $a,b$ share no common factors. Then 
$$a^p = mb + 1$$
for some $m,p \in \integers$.
\label{nonCommonPower}
\end{theorem}

\begin{theorem} %I'm not proving the theorem, but i'm refrencing it. How should this be done mathematically?
%TODO find name of this theorem

Given $a^x = mN + r$ for $a,x,m,N,r \in \integers$. Then
$$a^{x + yp} = kN + r$$
for some $y,p,k \in \integers$.
\label{repeatingPower}
\end{theorem}

We know that the guess given to the quantum portion of this algorithm, $g$, does not share any factors with the number we are trying to factor, $C$. Then by theorem \ref{nonCommonPower} we can express this as $r^p = mC + 1$. We can rearrange this to $(r^{p/2} + 1)(r^{p/2} - 1) = mC$. Then we know that our factors of $C$ are related to $(r^{p/2} + 1)$ and $(r^{p/2} - 1)$. Once we find these numbers, we can use Euler's formula to calculate the factors. 

In order to find $p$ we use theorem \ref{repeatingPower} and some properties of quantum computers. By theorem \ref{repeatingPower}, we know that $g^{x + yp} = kC + r$ mod(C) = $r$ $\forall y \in \integers$. So we can raise our guess to integer powers and search for when the remainder repeats. Classically, we cannot do this efficiently. However, with quantum computers we have a superposition of states that we can exploit to efficiently compute this. If we poll a random remainder value from our modulus calculation we get a superposition of the states that result in this value: $g^{x}$, $g^{x + p}$, $g^{x+2p}$... This has a period of $p$ which we can by taking the Fourier transform of this superposition. The Fourier transform returns the period of the function. Assuming that $p$ is even, then we are done! We have now found the factors of $C$. If $p$ is odd, then $r^{p/2}$ is not an integer, and we have to restart the process with a new guess. 

\end{document}
