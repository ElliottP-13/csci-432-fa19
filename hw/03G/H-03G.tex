\documentclass{article}
\usepackage{/fasy-hw}
\usepackage{ wasysym }

%% UPDATE these variables:
\renewcommand{\hwnum}{3}
\author{TODO-Your Group Number and Names Here}
\collab{TODO-list your collaborators here}
\date{due: 18 October 2019}

\begin{document}

\nextprob
If 23 people are in a room, then the probability that at least two of them have
the same birthday is at least one half.  This is known as the birthday paradox,
since the number 23 is probably much lower than you would expect.  How many
people do we need in order to have 50\% probability that there are three people
with the same birthday?


% TODO: temp answer
\textbf{Answer: }  The probability of three people having the same birthday is $\frac{365}{365} \cdot \frac{1}{365} \cdot \frac{1}{365}$

The ways of choosing three people is $n\choose{3}$.

Therefore the people we need for 0.5 chance to get three people on the same birthday is 

$\frac{1}{2}$ = $n \choose 3$ $(\frac{1}{365})^2 $, $n = 75$


\nextprob
Suppose we have a graph $G=(V,E)$ and three colors, and randomly assign a color
each node (where each color is equally likely).
\begin{enumerate}
   \item What is the probability that every edge has two different colors on
        assigned to its two nodes?
        
        \textbf{Answer:} For every edge, there are two nodes and three colors, say color a, b, and c.
        
        The total number of possible color combinations is 9. And 3 of them are same color combinations.
        
        Therefore the probability of two different colors is $P = \frac{9-3}{9} = \frac{2}{3}$.
        
    \item What is the expected number of edges that have different colors
        assigned to its two nodes?
        
        % TODO: Solve this part of the problem
        
\end{enumerate}

\nextprob
CLRS, Question 15-6.


\begin{algorithm}
    \caption{Guest List}\label{guests}
    \begin{algorithmic}[1]
    \Function{Guests}{$G$}
        \State guests\{\{\}\}
        \State vivality\{\}
        \For{$i$ in $[1, n]$}
			\State node = find next lowest node in graph
			\If{node doesn't have any children}
				\State guests[node] = \{node\}
				\State vivality[node] = node.vivality
			\Else
				\State $c = \sum_{child} vivality[child]$
				\State $g = node.vivality + \sum_{grandChild} vivality[grandChild]$
				
				\If{c > g}
					\State $guests[node] = \sum_{child} guests[child]$
					\State $vivality[node] = c$
				\Else
					\State $guests[node] = \{node\} + \sum_{grandChild} vivality[grandChild]$
					\State $vivality[node] = g$
				\EndIf
			\EndIf
		\EndFor
       \State \textbf{return} guests
    \EndFunction
    \end{algorithmic}
\end{algorithm}

This algorithm creates two lists that are indexed by the verticies of the graph. It then locates the node that is furthest down the tree that has not yet been explored. The if statement checks if the node is a leaf node. Otherwise, the optimal solution at that node is either one of two choices. The first one is if we choose the node and thus cannot choose the children, but we can choose the grandchildren. The second choice is if we do not choose the node so that we can choose the children. The second if statement takes care of these cases. This algorithm builds the optimal solution starting at the bottom nodes and builds up to the final solution.

The decrimenting function for the for loop would be $n - i$ this approaches zero as $i$
 approaches $n$. This maps to a well ordered set and decreases each itteration, and the algororithm therefore terminates.
 
 The runtime for this algorithm is $O(n^2)$. The loop repeats $n$ times. Inside the loop, the "find next lowest node in graph", as well as the summations all take $O(n)$ time. Thus, inside the loop is a summation of $O(n)$ processes, which is therefore also $O(n)$. So, an $O(n)$ process is repeated n times, and the overall runtime is $O(n^2)$.
 
 %TODO Loop invariant

\nextprob
For the Greedy make change algorithm described in class on 10/02, describe the
problem and solution in your own words, including the use of pseudocode (with
more details than what was written in class).  Note: you do not need to give a
loop invariant and the proof of termination/runtime complexity.

\textbf{Answer:} The Greedy Make Change algorithm is used to solve an optimization problem. It has many solutions, but we wish to min/max some function defined over those solutions. The solutions are the different ways to make change. To optimize the solution means to minimize the number of coins used. And the solution might not be unique.

\textbf{Pseudocode:}
\begin{algorithm}
            \begin{algorithmic}
            \State $val$: the total value we want to make change from
            \State $d = [d_1, d_2, d_3, ......, d_k]$: a list of the changes we can make into (1 cent, 5 cents, 10 cents, etc.)
                \Function{GMC}{val: Integer, d: array}
                    \State $S$: empty set to store the solution
                    \State sort $d$ from largest to smallest
                    \For{i = 1...k}
                        \State $amount = val // d_i$
                        \State add $amount$ of $d_i$ to $S$  \Comment{add as many $d_i$ as possible to $S$}
                    \EndFor
                    \newline
                    \Return $S$
                \EndFunction
            \end{algorithmic}
            \end{algorithm}

\nextprob
Suppose we have $n$ items hat we want to put in a knapsack of capacity $W$.  The i-th item has
weight $w_i$ and value $v_i$.  The knapsack can hold a total weight of $W$ and
we want to maximize the value of the items in the knapsack.
The \emph{0-1 knapsack problem} will assign each item one of two states: in the
knapsack, or not in the knapsack.  The \emph{fractional knapsack problem} allows
you to take a percentage of each item.
\begin{enumerate}
    \item Give an $O(n\log n)$ greedy algorithm for the fractional knapsack problem.
    
%Sort by value/weight
%Add the items with highest value/weight ratio. 
%if out of space, add fraction of last item st. W is full    
    
    \item Give an $O(nW)$ time algorithm that uses dynamic programming to solve
        the 0-1 knapsack problem.
        
%I don't really know
%Start with weight of zero. --> optimal solution is no items
%increment weight
%then I get stuck
\end{enumerate}

\end{document}
